MODULE Euler;
  IMPORT Out, Math;

  CONST PrintWidth = 12;

(****************************** 1 *********************************

If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9.
The sum of these multiples is 23.
Find the sum of all the multiples of 3 or 5 below 1000.
*******************************************************************)

  PROCEDURE Problem1*;
    VAR sum, i: INTEGER;
  BEGIN
    i := 3; sum := 0;
    WHILE i < 1000 DO
      IF (i MOD 3 = 0) OR (i MOD 5 = 0) THEN sum := sum + i END;
      i := i + 1;
    END;
    ASSERT(sum = 233168);
    Out.Int(sum, PrintWidth);
  END Problem1;


(****************************** 2 *********************************

Each new term in the Fibonacci sequence is generated by adding the previous two terms.
By starting with 1 and 2, the first 10 terms will be:
1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
By considering the terms in the Fibonacci sequence whose values do not exceed four million,
find the sum of the even-valued terms.
*******************************************************************)

  PROCEDURE Problem2*;
    VAR a, next, t, sum: INTEGER;
  BEGIN
    a := 1; next := 2; sum := 0;
    WHILE next < 4000000 DO
      IF ~ODD(next) THEN sum := sum + next END;
      t := next; next := next + a; a := t;
    END;
    ASSERT(sum = 4613732);
    Out.Int(sum, PrintWidth);
  END Problem2;


(****************************** 3 *********************************

The prime factors of 13195 are 5, 7, 13 and 29.
What is the largest prime factor of the number 600851475143 ?

** Requires an oberon compiler which supports LONGINT, e.g. obc **
*******************************************************************)

  PROCEDURE nextPrimeDivisor(dividend: INTEGER): INTEGER;
    VAR result, currDivisor: INTEGER; found: BOOLEAN;
  BEGIN result := dividend; currDivisor := 1; found := FALSE;
    REPEAT
      INC(currDivisor);
      IF (dividend MOD currDivisor) = 0 THEN
        result := currDivisor; found := TRUE;
      END
    UNTIL found OR (FLT(currDivisor) > Math.sqrt(FLT(dividend)));
    RETURN result
  END nextPrimeDivisor;

  PROCEDURE Problem3*;
    VAR num, nextPrime: INTEGER;
  BEGIN num := 2147483647 (* 600851475143 *); nextPrime := 1;
    WHILE num # nextPrime DO
      num := num DIV nextPrime;
      nextPrime := nextPrimeDivisor(num);
    END;
    (* ASSERT(nextPrime = 6857); *)
    Out.Int(nextPrime, PrintWidth);
  END Problem3;


(****************************** 4 *********************************

A palindromic number reads the same both ways.
The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 Ã— 99.
Find the largest palindrome made from the product of two 3-digit numbers.
*******************************************************************)

  PROCEDURE reverseInt(i: INTEGER): INTEGER;
    VAR result: INTEGER;
  BEGIN
    result := 0;
    WHILE i > 0 DO
      result := result * 10 + (i MOD 10);
      i := i DIV 10;
    END;
    RETURN result
  END reverseInt;

  PROCEDURE Problem4*;
    VAR i, j, prod, reverse, result: INTEGER;
  BEGIN
    result:=0;
    FOR i := 100 TO 999 DO
      FOR j := 100 TO 999 DO
        prod := i*j;
        reverse := reverseInt(prod);
        IF (prod = reverse) & (prod > result) THEN
          result := prod
        END
      END
    END;
    ASSERT(result = 906609);
    Out.Int(result, PrintWidth);
  END Problem4;


(****************************** 5 *********************************

2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder.
What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20?
*******************************************************************)

  (* lcm(a,b) * gcd(a,b) = a*b *)
  PROCEDURE lcm(a, b: INTEGER): INTEGER;
    VAR x, y: INTEGER;
  BEGIN
    x := a; y := b;
    (*
       gcd(a,b) = gcd(a0,b0)
       a*x + b*y = 2*a0*b0
    *)
    WHILE a > b DO
      a := a - b;
      x := x + y;
    ELSIF a < b DO
      b := b - a;
      y := y + x;
    END
    (*
       greatest common divisor = a (or b)
       least common multiple = (x+y) / 2
    *)
    RETURN (x+y) DIV 2
  END lcm;

  PROCEDURE Problem5*;
    VAR i, result: INTEGER;
  BEGIN result := 1;
    FOR i := 1 TO 20 DO
      result := lcm(result, i);
    END;
    ASSERT(result = 232792560);
    Out.Int(result, PrintWidth)
  END Problem5;


(****************************** 6 *********************************

The sum of the squares of the first ten natural numbers is 1^2 + 2^2 + ... + 10^2 = 385,
The square of the sum of the first ten natural numbers is (1 + 2 + ... + 10)^2 = 55^2 = 3025,
Hence the difference between the sum of the squares of the first ten natural numbers and the square of the sum is 3025 - 385 = 2640.
Find the difference between the sum of the squares of the first one hundred natural numbers and the square of the sum.
*******************************************************************)

  PROCEDURE Problem6*;
    VAR i, sum, sqSum, result: INTEGER;
  BEGIN sum := 0; sqSum := 0;
    FOR i := 1 TO 100 DO
      sum := sum + i;
      sqSum := sqSum + i * i;
    END;
    result := sum*sum - sqSum;
    ASSERT(result = 25164150);
    Out.Int(result, PrintWidth)
  END Problem6;


(****************************** 7 *********************************

By listing the first six prime numbers: 2, 3, 5, 7, 11, and 13, we can see that the 6th prime is 13.
What is the 10001st prime number?
*******************************************************************)

  PROCEDURE findPrimes(VAR toBePrimes: ARRAY OF INTEGER);
    VAR
      primeIndex, checkIndex, primeCandidate, increment, indexOfLastSquaredPrime, square: INTEGER;
      isPrime: BOOLEAN;
      notPrimes: ARRAY 1500 OF INTEGER; (* should be ~ square root of len(toBePrimes) *)
  BEGIN
    square := 4;     (* square of the first prime (i.e. 2) *)
    primeIndex := 2; (* we start our search from the 3rd prime (i.e. 5) *)
    increment := 4;  (* alternate between 2 and 4 increments, excluding multiples of 2 and 3 ab initio *)
    primeCandidate := 1;
    indexOfLastSquaredPrime := 0;
    WHILE primeIndex < LEN(toBePrimes) DO
      REPEAT
        primeCandidate := primeCandidate + increment;
        increment := 6 - increment;
        IF primeCandidate >= square THEN
          notPrimes[indexOfLastSquaredPrime] := square;
          INC(indexOfLastSquaredPrime);
          square := toBePrimes[indexOfLastSquaredPrime] * toBePrimes[indexOfLastSquaredPrime]
        END;
        isPrime := TRUE;
        checkIndex := 1;
        WHILE isPrime & (checkIndex < indexOfLastSquaredPrime) DO
          INC(checkIndex);
          IF primeCandidate > notPrimes[checkIndex] THEN
            notPrimes[checkIndex] := notPrimes[checkIndex] + toBePrimes[checkIndex]
          END;
          isPrime := primeCandidate # notPrimes[checkIndex]
        END
      UNTIL isPrime;
      toBePrimes[primeIndex] := primeCandidate;
      INC(primeIndex);
    END;
  END findPrimes;

  PROCEDURE Problem7*;
    VAR result: INTEGER;
      primes: ARRAY 10001 OF INTEGER;
  BEGIN
    findPrimes(primes);
    result := primes[LEN(primes)-1];
    ASSERT(result = 104743);
    Out.Int(result, PrintWidth)
  END Problem7;

BEGIN
  Problem1; Out.Ln;
  Problem2; Out.Ln;
  Problem3; Out.Ln;
  Problem4; Out.Ln;
  Problem5; Out.Ln;
  Problem6; Out.Ln;
  Problem7; Out.Ln;
END Euler.
